package com.cig.mctbnc.learning.structure;

import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import com.cig.mctbnc.data.representation.Dataset;
import com.cig.mctbnc.learning.parameters.BNParameterLearning;
import com.cig.mctbnc.models.BN;
import com.cig.mctbnc.nodes.CPTNode;
import com.cig.mctbnc.nodes.Node;
import com.cig.mctbnc.util.Util;
import com.cig.mctbnc.view.CommandLine;

public class BNStructureHillClimbing implements BNStructureLearning {

	List<Node> nodes;
	Dataset trainingDataset;
	BNParameterLearning bnParameterLearning;
	boolean[][] initialAdjacencyMatrix;
	static Logger logger = LogManager.getLogger(BNStructureHillClimbing.class);

	@Override
	public void learn(BN<? extends Node> bn, BNParameterLearning bnParameterLearning, Dataset trainingDataset) {

		logger.info("Learning Bayesian network using Hill Climbing");

		// Define nodes of the bayesian network
		this.nodes = bn.getNodes();

		// Define parameter learning algorithm
		this.bnParameterLearning = bnParameterLearning;

		// Get initial structure
		this.initialAdjacencyMatrix = bn.getAdjacencyMatrix();

		// Define training dataset
		this.trainingDataset = trainingDataset;

		// Obtain best neighbor
		boolean[][] bestStructure = findStructure();
		bn.setStructure(bestStructure);
	}

	/**
	 * Performs greedy Hill climbing to find a better structure from the initial one.
	 * @return
	 */
	public boolean[][] findStructure() {

		boolean[][] bestStructure = initialAdjacencyMatrix.clone();
		double bestScore = Double.NEGATIVE_INFINITY;
		int numNodes = bestStructure.length;

		boolean improvement;
		do {
			improvement = false;

			// Store scores and respective structures for each operation (addition, deletion
			// and reversal)
			double[] scores = { Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY };
			boolean[][][] adjacencyMatrices = new boolean[3][numNodes][numNodes];

			// Structures generated by addition
			findBestNeighbor(bestStructure, scores, adjacencyMatrices, "addition");

			// Structures generated by deletion
			findBestNeighbor(bestStructure, scores, adjacencyMatrices, "deletion");

			// Structures generated by reversal
			findBestNeighbor(bestStructure, scores, adjacencyMatrices, "reversal");

			int idxBestOperation = Util.getIndexLargestValue(scores);
			double iterationBestScore = scores[idxBestOperation];
			if (iterationBestScore > bestScore) {
				logger.debug("Score improved! From {} to {}", bestScore, iterationBestScore);
				bestScore = iterationBestScore;
				bestStructure = adjacencyMatrices[idxBestOperation];
				improvement = true;
			}

		} while (improvement);

		return bestStructure;
	}

	/**
	 * Find the best neighbor of the adjacency matrix "bestStructure" given an
	 * operation to perform.
	 * 
	 * @param bestStructure
	 * @param scores
	 * @param adjacencyMatrices
	 * @param operation
	 *            Possible operations to perform over the adjacency matrix. These
	 *            are addition, deletion or reversal of arcs.
	 */
	private void findBestNeighbor(boolean[][] bestStructure, double[] scores, boolean[][][] adjacencyMatrices,
			String operation) {

		// Define the index of the operation. It will be used to store the score and
		// adjacency matrix
		// in the correct position of the arrays.
		int idxOperation = operation == "addition" ? 0 : operation == "deletion" ? 1 : 2;
		int numNodes = bestStructure.length;
		for (int i = 0; i < numNodes; i++) {
			for (int j = 0; j < numNodes; j++) {
				if (i != j) {

					// Copy current best neighbor
					boolean[][] tempAdjacencyMatrix = new boolean[numNodes][numNodes];
					for (int r = 0; r < numNodes; r++) {
						tempAdjacencyMatrix[r] = bestStructure[r].clone();
					}

					if (operation == "addition") {
						// Arc is added
						tempAdjacencyMatrix[i][j] = true;
					} else if (operation == "deletion") {
						// Arc is removed
						tempAdjacencyMatrix[i][j] = false;
					} else {
						// Arc is reversed
						tempAdjacencyMatrix[i][j] = false;
						tempAdjacencyMatrix[j][i] = true;
					}

					if (structureIsLegal(tempAdjacencyMatrix)) {
						// Define Bayesian network with the modified adjacency matrix
						BN<CPTNode> bn = new BN<CPTNode>(nodes, trainingDataset);
						bn.setParameterLearningAlgorithm(bnParameterLearning);
						bn.setStructure(tempAdjacencyMatrix);
						double obtainedScore = StructureScoreFunctions.bnPenalizedLogLikelihoodScore(bn);

						if (scores[idxOperation] < obtainedScore) {
							scores[idxOperation] = obtainedScore;
							adjacencyMatrices[idxOperation] = tempAdjacencyMatrix;
						}
					}
				}
			}
		}

	}

	/**
	 * Check if the structure (given by a adjacencyMatrix) is legal for a Bayesian
	 * network.
	 * 
	 * @param adjacencyMatrix
	 * @return
	 */
	private boolean structureIsLegal(boolean[][] adjacencyMatrix) {
		boolean legalStructure = !isCyclic(adjacencyMatrix);
		return legalStructure;
	}

	/**
	 * Determine if there are cycles in an adjacency matrix. Modified version of code in
	 * https://www.geeksforgeeks.org/detect-cycle-in-a-directed-graph-using-bfs/.
	 * 
	 * @param adjacencyMatrix
	 * @return
	 */
	private boolean isCyclic(boolean[][] adjacencyMatrix) {

		int numNodes = adjacencyMatrix.length;

		// Indegrees of all nodes.
		int[] inDegree = new int[numNodes];

		for (int i = 0; i < numNodes; i++) {
			for (int j = 0; j < numNodes; j++) {
				if (i != j && adjacencyMatrix[i][j]) {
					inDegree[j]++;
				}
			}
		}

		// Enqueue all nodes with indegree 0
		Queue<Integer> q = new LinkedList<Integer>();
		for (int i = 0; i < numNodes; i++)
			if (inDegree[i] == 0)
				q.add(i);

		// Initialize count of visited vertices
		int countVisitedNodes = 0;

		// One by one dequeue vertices from queue and enqueue
		// adjacents if indegree of adjacent becomes 0
		while (!q.isEmpty()) {

			// Extract node from queue
			int i = q.poll();

			// Iterate over all children nodes of dequeued node i and
			// decrease their in-degree by 1
			for (int j = 0; j < numNodes; j++)
				if (i != j && adjacencyMatrix[i][j] && --inDegree[j] == 0)
					q.add(j);
			countVisitedNodes++;
		}

		// If the number of visited nodes are different than the number
		// of nodes in the graph, there are cycles
		return !(countVisitedNodes == numNodes);

	}

}
