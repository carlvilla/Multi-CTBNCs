package es.upm.fi.cig.multictbnc.learning.structure.optimisation.hillclimbing.implementation;

import es.upm.fi.cig.multictbnc.learning.structure.optimisation.hillclimbing.HillClimbingSolution;
import es.upm.fi.cig.multictbnc.learning.structure.optimisation.scores.bn.BNScoreFunction;
import es.upm.fi.cig.multictbnc.models.BN;
import es.upm.fi.cig.multictbnc.models.PGM;
import es.upm.fi.cig.multictbnc.nodes.Node;
import es.upm.fi.cig.multictbnc.util.Util;
import org.apache.commons.lang3.NotImplementedException;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.util.List;
import java.util.Map;

/**
 * Implements hill climbing algorithm for BNs.
 *
 * @author Carlos Villa Blanco
 */
public class BNHillClimbing implements HillClimbingImplementation {
	BNScoreFunction scoreFunction;
	private int numEdgesTested = 0;
	private static final Logger logger = LogManager.getLogger(BNHillClimbing.class);

	/**
	 * Constructor that receives the score function to optimise.
	 *
	 * @param scoreFunction score function for Bayesian networks
	 */
	public BNHillClimbing(BNScoreFunction scoreFunction) {
		this.scoreFunction = scoreFunction;
	}

	/**
	 * Checks if a solution given by the hill climbing algorithm in a certain iteration is better than the current
	 * solution.
	 *
	 * @param solution           current solution
	 * @param adjacencyMatrices  best adjacency matrices given by each possible operation
	 * @param idxBestOperation   index of the best operation
	 * @param iterationBestScore score of the iteration solution
	 * @return {@code true} if the solution of the iteration is better than the current solution, {@code false}
	 * otherwise
	 */
	protected boolean isScoreImproved(HillClimbingSolution solution, boolean[][][] adjacencyMatrices,
									  int idxBestOperation, double iterationBestScore) {
		if (iterationBestScore > solution.getScore()) {
			logger.debug("Score improved! From {} to {}", solution.getScore(), iterationBestScore);
			logger.debug("New structure: {}", (Object) adjacencyMatrices[idxBestOperation]);
			solution.setAdjacencyMatrix(adjacencyMatrices[idxBestOperation]);
			solution.setScore(iterationBestScore);
			return true;
		}
		return false;
	}

	@Override
	public HillClimbingSolution findStructure(PGM<? extends Node> pgm) {
		logger.info("Learning {} using Hill Climbing", pgm.getType());
		// Retrieve the model, initial structure and number of nodes
		BN<? extends Node> bn = (BN<? extends Node>) pgm;
		boolean[][] currentStructure = bn.getAdjacencyMatrix().clone();
		int numNodes = currentStructure.length;
		// Define object to store final solution
		HillClimbingSolution solution = new HillClimbingSolution();
		solution.setAdjacencyMatrix(currentStructure);
		solution.setScore(Double.NEGATIVE_INFINITY);
		boolean improvement;
		do {
			// Store scores and respective structures for each operation (addition, deletion
			// and reversal)
			double[] scores = {Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY};
			boolean[][][] adjacencyMatrices = new boolean[3][numNodes][numNodes];
			// Structures generated by addition
			findBestNeighbor(bn, solution, scores, adjacencyMatrices, "addition");
			// Structures generated by deletion
			findBestNeighbor(bn, solution, scores, adjacencyMatrices, "deletion");
			// Structures generated by reversal
			findBestNeighbor(bn, solution, scores, adjacencyMatrices, "reversal");
			int idxBestOperation = Util.getIndexLargestValue(scores);
			double iterationBestScore = scores[idxBestOperation];
			logger.trace("Iteration best score {}", iterationBestScore);
			improvement = isScoreImproved(solution, adjacencyMatrices, idxBestOperation, iterationBestScore);
		} while (improvement);
		logger.info("Number of edges tested to learn the class subgraph: {}", getNumEdgesTested());
		resetNumEdgesTested();
		return solution;
	}

	/**
	 * Finds the best neighbour of the adjacency matrix "bestStructure" given an operation to perform (addition,
	 * deletion or reversal of arcs).
	 *
	 * @param bn                Bayesian network whose structure is being learnt
	 * @param bestSolution      best structure so far
	 * @param scores            two-dimensional {@code double} array containing the structure scores after applying
	 *                             each
	 *                          of the possible operations over the adjacency matrix
	 * @param adjacencyMatrices three-dimensional {@code boolean} array containing the resulting adjacency matrices
	 *                          after applying each of the possible operations over the original matrix
	 * @param operation         operation to perform over the adjacency matrix
	 */
	protected void findBestNeighbor(BN<? extends Node> bn, HillClimbingSolution bestSolution, double[] scores,
									boolean[][][] adjacencyMatrices, String operation) {
		// Define the index of the operation. It will be used to store the score and
		// adjacency matrix
		// in the correct position of the arrays.
		int idxOperation = operation.equals("addition") ? 0 : operation.equals("deletion") ? 1 : 2;
		boolean[][] bestStructure = bestSolution.getAdjacencyMatrix();
		int numNodes = bestStructure.length;
		for (int i = 0; i < numNodes; i++) {
			for (int j = 0; j < numNodes; j++)
				if (i != j) {
					// Copy current best neighbour
					boolean[][] tempAdjacencyMatrix = new boolean[numNodes][numNodes];
					for (int r = 0; r < numNodes; r++)
						tempAdjacencyMatrix[r] = bestStructure[r].clone();
					if (operation == "addition") {
						if (tempAdjacencyMatrix[i][j])
							// If there is already an arc, the operation is not performed
							continue;
						// Arc is added
						tempAdjacencyMatrix[i][j] = true;
						increaseNumEdgesTested();
					} else if (operation == "deletion") {
						if (!tempAdjacencyMatrix[i][j])
							// If there is no arc, the operation cannot be performed
							continue;
						// Arc is removed
						tempAdjacencyMatrix[i][j] = false;
						increaseNumEdgesTested();
					} else {
						if (!tempAdjacencyMatrix[i][j])
							// If there is no arc, the operation cannot be performed
							continue;
						// Arc is reversed
						tempAdjacencyMatrix[i][j] = false;
						tempAdjacencyMatrix[j][i] = true;
						increaseNumEdgesTested();
					}
					if (bn.isStructureLegal(tempAdjacencyMatrix)) {
						logger.trace("Studying new {} structure: {}", bn.getType(), tempAdjacencyMatrix);
						// Retrieve score BN with the modified adjacency matrix
						double score = computeScore(bn, tempAdjacencyMatrix);
						if (scores[idxOperation] < score) {
							scores[idxOperation] = score;
							adjacencyMatrices[idxOperation] = tempAdjacencyMatrix;
						}
					}
				}
		}
	}

	/**
	 * Computes the score of a structure given an adjacency matrix.
	 *
	 * @param bn              Bayesian network whose structure is being learnt
	 * @param adjacencyMatrix adjacency matrix of the structure
	 * @return score of the structure
	 */
	protected double computeScore(BN<? extends Node> bn, boolean[][] adjacencyMatrix) {
		// Establish the structure defined in an adjacency matrix and return its score
		bn.setStructureModifiedNodes(adjacencyMatrix);
		return this.scoreFunction.compute(bn);
	}

	@Override
	public Map<String, String> getInfoScoreFunction() {
		return Map.of("scoreFunction", this.scoreFunction.getIdentifier(), "penalisationFunction",
				this.scoreFunction.getNamePenalisationFunction());
	}

	@Override
	public HillClimbingSolution findStructure(PGM<? extends Node> pgm, int idxNode) {
		throw new NotImplementedException("Feature not yet implemented");
	}

	@Override
	public HillClimbingSolution findStructure(PGM<? extends Node> pgm, List<Integer> idxNodes) {
		throw new NotImplementedException("Feature not yet implemented");
	}

	/**
	 * Increases the number of evaluated edges in one.
	 */
	protected void increaseNumEdgesTested() {
		this.numEdgesTested++;
	}

	/**
	 * Sets to zero the number of evaluated edges.
	 */
	protected void resetNumEdgesTested() {
		this.numEdgesTested = 0;
	}

	/**
	 * Returns the number of edges that have been evaluated so far.
	 *
	 * @return number of edges that have been evaluated so far
	 */
	public int getNumEdgesTested() {
		return numEdgesTested;
	}

	@Override
	public String getIdentifier() {
		return "Hill climbing";
	}

	@Override
	public Map<String, String> getParametersAlgorithm() {
		return getInfoScoreFunction();
	}

}
