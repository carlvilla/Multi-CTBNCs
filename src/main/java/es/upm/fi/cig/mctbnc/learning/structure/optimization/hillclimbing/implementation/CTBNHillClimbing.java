package es.upm.fi.cig.mctbnc.learning.structure.optimization.hillclimbing.implementation;

import java.util.Map;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import es.upm.fi.cig.mctbnc.learning.structure.optimization.hillclimbing.HillClimbingSolution;
import es.upm.fi.cig.mctbnc.learning.structure.optimization.scores.ctbn.CTBNScoreFunction;
import es.upm.fi.cig.mctbnc.models.CTBN;
import es.upm.fi.cig.mctbnc.models.PGM;
import es.upm.fi.cig.mctbnc.nodes.Node;
import es.upm.fi.cig.mctbnc.util.Util;

/**
 * Implements hill climbing algorithm for CTBNs. This class is used with scores
 * that cannot be optimized by finding the best parent set for each node
 * individually. This is the case of, for example, the conditional
 * log-likelihood.
 * 
 * @author Carlos Villa Blanco
 *
 */
public class CTBNHillClimbing implements HillClimbingImplementation {
	CTBNScoreFunction scoreFunction;
	static Logger logger = LogManager.getLogger(CTBNHillClimbing.class);

	/**
	 * Constructor that receives the score function to optimize.
	 * 
	 * @param scoreFunction score function for continuous time Bayesian networks
	 */
	public CTBNHillClimbing(CTBNScoreFunction scoreFunction) {
		this.scoreFunction = scoreFunction;
	}

	@Override
	public HillClimbingSolution findStructure(PGM<? extends Node> pgm) {
		// Retrieve the model, initial structure and number of nodes
		CTBN<? extends Node> ctbn = (CTBN<? extends Node>) pgm;
		boolean[][] currentStructure = pgm.getAdjacencyMatrix().clone();
		int numNodes = currentStructure.length;
		// Define object to store final solution
		HillClimbingSolution solution = new HillClimbingSolution();
		solution.setScore(Double.NEGATIVE_INFINITY);
		boolean improvement;
		do {
			improvement = false;
			// Store scores and respective structures for each operation (addition, deletion
			// and reversal)
			double[] scores = { Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY };
			boolean[][][] adjacencyMatrices = new boolean[3][numNodes][numNodes];
			// Structures generated by addition
			findBestNeighbor(ctbn, currentStructure, scores, adjacencyMatrices, "addition");
			// Structures generated by deletion
			findBestNeighbor(ctbn, currentStructure, scores, adjacencyMatrices, "deletion");
			// Structures generated by reversal
			findBestNeighbor(ctbn, currentStructure, scores, adjacencyMatrices, "reversal");
			int idxBestOperation = Util.getIndexLargestValue(scores);
			double iterationBestScore = scores[idxBestOperation];
			logger.trace("Iteration best score {}", iterationBestScore);
			if (iterationBestScore > solution.getScore()) {
				logger.debug("Score improved! From {} to {}", solution.getScore(), iterationBestScore);
				logger.debug("New structure: {}", (Object) adjacencyMatrices[idxBestOperation]);
				currentStructure = adjacencyMatrices[idxBestOperation];
				solution.setAdjacencyMatrix(adjacencyMatrices[idxBestOperation]);
				solution.setScore(iterationBestScore);
				improvement = true;
			}
		} while (improvement);
		return solution;
	}

	/**
	 * Finds the best neighbor of the adjacency matrix "bestStructure" given an
	 * operation to perform.
	 * 
	 * @param bestStructure
	 * @param scores
	 * @param adjacencyMatrices
	 * @param operation         Possible operations to perform over the adjacency
	 *                          matrix. These are addition, deletion or reversal of
	 *                          arcs.
	 * @param cache
	 */
	private void findBestNeighbor(CTBN<? extends Node> ctbn, boolean[][] bestStructure, double[] scores,
			boolean[][][] adjacencyMatrices, String operation) {
		// Define the index of the operation. It will be used to store the score and
		// adjacency matrix
		// in the correct position of the arrays.
		int idxOperation = operation == "addition" ? 0 : operation == "deletion" ? 1 : 2;
		int numNodes = bestStructure.length;
		for (int i = 0; i < numNodes; i++) {
			for (int j = 0; j < numNodes; j++)
				if (checkModificationAdjacencyMatrix(ctbn, i, j, idxOperation)) {
					// Copy current best neighbor
					boolean[][] tempAdjacencyMatrix = new boolean[bestStructure.length][];
					for (int r = 0; r < bestStructure.length; r++)
						tempAdjacencyMatrix[r] = bestStructure[r].clone();
					if (operation == "addition") {
						// An arc is added
						if (tempAdjacencyMatrix[i][j])
							// If there is already an arc, the operation is not performed
							continue;
						// Arc is added
						tempAdjacencyMatrix[i][j] = true;
					} else if (operation == "deletion") {
						// An arc is removed
						if (!tempAdjacencyMatrix[i][j])
							// If there is no arc, the operation cannot be performed
							continue;
						// Arc is removed
						tempAdjacencyMatrix[i][j] = false;
					} else {
						// An arc is reversed
						if (!tempAdjacencyMatrix[i][j] || ctbn.getNodeByIndex(i).isClassVariable())
							// If there is no arc, the operation cannot be performed. An arc from a class
							// variable to a feature cannot be reversed
							continue;
						// Arc is reversed
						tempAdjacencyMatrix[i][j] = false;
						tempAdjacencyMatrix[j][i] = true;
					}
					if (ctbn.isStructureLegal(tempAdjacencyMatrix)) {
						logger.trace("Studying new {} structure: {}", ctbn.getType(), tempAdjacencyMatrix);
						// Retrieve score CTBN with the modified adjacency matrix
						double score = computeScore(ctbn, tempAdjacencyMatrix);
						if (scores[idxOperation] < score) {
							scores[idxOperation] = score;
							adjacencyMatrices[idxOperation] = tempAdjacencyMatrix;
						}
					}
				}
		}
	}

	/**
	 * Checks if an arc between two nodes can be added. Arcs from any node to a class
	 * variable cannot be added, removed or reversed, and self-loops are also
	 * avoided.
	 * 
	 * @param i
	 * @param j
	 * @param idxOperation
	 * @return true if the arc can be added, false otherwise
	 */
	private boolean checkModificationAdjacencyMatrix(CTBN<? extends Node> ctbn, int i, int j, int idxOperation) {
		return i != j && !ctbn.getNodeByIndex(j).isClassVariable();
	}

	/**
	 * Computes the score of a structure given an adjacency matrix.
	 * 
	 * @param adjacencyMatrix
	 * @param modifiedNodes
	 * @return score
	 */
	private double computeScore(CTBN<? extends Node> ctbn, boolean[][] adjacencyMatrix) {
		// Set structure and obtain its score
		ctbn.setStructureModifiedNodes(adjacencyMatrix);
		return this.scoreFunction.compute(ctbn);
	}

	@Override
	public Map<String, String> getInfoScoreFunction() {
		return Map.of("scoreFunction", this.scoreFunction.getIdentifier(), "penalizationFunction",
				this.scoreFunction.getPenalization());
	}

}
